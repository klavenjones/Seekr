"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createVerificationRequest = void 0;
var client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
var bcrypt_1 = __importDefault(require("bcrypt"));
var DynamoDBAdapter_1 = require("../DynamoDBAdapter");
var createVerificationRequest = function (_a) {
    var client = _a.client, logger = _a.logger, appOptions = _a.appOptions, tableOptions = _a.tableOptions;
    return function (email, url, token, _secret, provider, _options) {
        var DEBUG_ID = 'createVerificationRequest';
        logger.debug(DEBUG_ID, email);
        var verificationRequestsTable = tableOptions.verificationRequestsTable;
        if (!verificationRequestsTable) {
            return Promise.reject(new Error('verificationRequestsTable name was not provided'));
        }
        var baseUrl = appOptions.baseUrl;
        var sendVerificationRequest = provider.sendVerificationRequest, maxAge = provider.maxAge;
        var expires = new Date(Date.now() + (maxAge || DynamoDBAdapter_1.VERIFICATION_TOKEN_MAX_AGE) * 1000);
        return new Promise(function (resolve, reject) {
            return bcrypt_1.default
                .hash(token, 10)
                .then(function (hashedToken) {
                return client.send(new client_dynamodb_1.PutItemCommand({
                    TableName: verificationRequestsTable,
                    Item: {
                        expires: { S: expires.toISOString() },
                        email: { S: email },
                        token: { S: hashedToken },
                    },
                }));
            })
                .then(function (_clientResponse) {
                return sendVerificationRequest({
                    identifier: email,
                    url: url,
                    token: token,
                    baseUrl: baseUrl,
                    provider: provider,
                });
            })
                .then(function (_verificationSenderResponse) {
                return resolve({
                    identifier: email,
                    token: token,
                    expires: expires,
                });
            })
                .catch(function (error) {
                logger.error(DEBUG_ID, error);
                reject(error);
            });
        });
    };
};
exports.createVerificationRequest = createVerificationRequest;
//# sourceMappingURL=createVerificationRequest.js.map